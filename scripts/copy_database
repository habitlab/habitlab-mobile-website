#!/usr/bin/env node
// Generated by LiveScript 1.5.0
(function(){
  var mongodb, getsecret, n2p, fs, storage, mongourl, mongourl2, memoizeSingleAsync, get_mongo_db, get_mongo_db2, sleep, keep_trying, sync_all_in_collection, sync_all_in_collection_fresh, list_collections, out$ = typeof exports != 'undefined' && exports || this;
  mongodb = require('mongodb');
  getsecret = require('getsecret');
  n2p = require('n2p');
  fs = require('fs-extra');
  storage = require('node-persist');
  mongourl = getsecret('MONGODB_SRC');
  mongourl2 = getsecret('MONGODB_DST');
  memoizeSingleAsync = function(func){
    var cached_promise;
    cached_promise = null;
    return function(){
      var result;
      if (cached_promise != null) {
        return cached_promise;
      }
      result = func();
      cached_promise = result;
      return result;
    };
  };
  out$.get_mongo_db = get_mongo_db = memoizeSingleAsync(async function(){
    var err;
    try {
      return (await n2p(function(it){
        return mongodb.MongoClient.connect(mongourl, {
          readPreference: mongodb.ReadPreference.SECONDARY,
          readConcern: {
            level: 'available'
          },
          w: 0,
          reconnectTries: Number.MAX_VALUE,
          reconnectInterval: 1000,
        }, it);
      }));
    } catch (e$) {
      err = e$;
      console.error('error getting mongodb');
      console.error(err);
    }
  });
  out$.get_mongo_db2 = get_mongo_db2 = memoizeSingleAsync(async function(){
    var err;
    try {
      return (await n2p(function(it){
        return mongodb.MongoClient.connect(mongourl2, {
          readPreference: mongodb.ReadPreference.SECONDARY,
          readConcern: {
            level: 'available'
          },
          w: 0,
          reconnectTries: Number.MAX_VALUE,
          reconnectInterval: 1000,
        }, it);
      }));
    } catch (e$) {
      err = e$;
      console.error('error getting mongodb2');
      console.error(err);
    }
  });
  sleep = async function(time){
    return new Promise(function(it){
      return setTimeout(it, time);
    });
  };
  keep_trying = async function(fn){
    var succeeded, output, error;
    succeeded = false;
    while (!succeeded) {
      try {
        output = (await n2p(fn));
        succeeded = true;
      } catch (e$) {
        error = e$;
        console.log(error);
        (await sleep(12000));
      }
    }
    return output;
  };
  sync_all_in_collection = async function(collection_name, db_src, db_dst){
    var c_src, c_dst, all_ids_src, all_ids_dst, all_ids_dst_str, dst_id_set, all_ids_which_need_to_be_inserted, all_items_src, all_items_which_need_to_be_inserted, i$, len$, idname, item_src, this$ = this;
    c_src = db_src.collection(collection_name);
    c_dst = db_dst.collection(collection_name);
    all_ids_src = (await keep_trying(function(it){
      return c_src.find({}, {
        _id: 1
      }).toArray(it);
    }));
    all_ids_src = all_ids_src.map(function(it){
      return it._id;
    });
    if (all_ids_src.length === 0) {
      return;
    }
    all_ids_dst = (await keep_trying(function(it){
      return c_dst.find({}, {
        _id: 1
      }).toArray(it);
    }));
    all_ids_dst = all_ids_dst.map(function(it){
      return it._id;
    });
    all_ids_dst_str = all_ids_dst.map(function(it){
      return it.toString();
    });
    dst_id_set = new Set(all_ids_dst_str);
    all_ids_which_need_to_be_inserted = all_ids_src.filter(function(x){
      return !dst_id_set.has(x.toString());
    });
    if (all_ids_which_need_to_be_inserted.length === 0) {
      return;
    }
    if (all_ids_which_need_to_be_inserted.length * 2 >= all_ids_src.length) {
      console.log('bulk incrementally inserting ' + all_ids_which_need_to_be_inserted.length + ' items');
      all_items_src = (await keep_trying(function(it){
        return c_src.find({}).toArray(it);
      }));
      if (all_items_src.length === 0) {
        return;
      }
      all_items_which_need_to_be_inserted = all_items_src.filter(function(x){
        return !dst_id_set.has(x._id.toString());
      });
      if (all_items_which_need_to_be_inserted.length === 0) {
        return;
      }
      (await keep_trying(function(it){
        return c_dst.insertMany(all_items_which_need_to_be_inserted, it);
      }));
    } else {
      console.log('individually incrementally inserting ' + all_ids_which_need_to_be_inserted.length + ' items');
      for (i$ = 0, len$ = all_ids_which_need_to_be_inserted.length; i$ < len$; ++i$) {
        idname = all_ids_which_need_to_be_inserted[i$];
        item_src = (await keep_trying(fn$));
        if (item_src == null) {
          console.log('could not find item with id ' + idname + ' in collection ' + collection_name);
          process.exit();
        }
        (await keep_trying(fn1$));
      }
    }
    function fn$(it){
      return c_src.find({
        _id: idname
      }).toArray(it);
    }
    function fn1$(it){
      return c_dst.insert(item_src, it);
    }
  };
  sync_all_in_collection_fresh = async function(collection_name, db_src, db_dst){
    var c_src, c_dst, all_items_src;
    c_src = db_src.collection(collection_name);
    c_dst = db_dst.collection(collection_name);
    all_items_src = (await keep_trying(function(it){
      return c_src.find({}).toArray(it);
    }));
    if (all_items_src.length === 0) {
      return;
    }
    console.log('freshly inserting ' + all_items_src.length + ' items');
    return (await keep_trying(function(it){
      return c_dst.insertMany(all_items_src, it);
    }));
  };
  list_collections = async function(db_src){
    var collections_src, all_items_src, output, this$ = this;
    collections_src = db_src.collection('collections');
    all_items_src = (await keep_trying(function(it){
      return collections_src.find({}, {
        _id: 1
      }).toArray(it);
    }));
    output = all_items_src.map(function(it){
      return it._id;
    });
    if (output.indexOf('collections') === -1) {
      output.push('collections');
    }
    return output;
  };
  (async function(){
    var db_src, db_dst, argv, all_collections, dst_collections, dst_collections_set, num_to_sync, num_threads, resumable, start_thread, i$, threadnum, results$ = [];
    db_src = (await get_mongo_db());
    db_dst = (await get_mongo_db2());
    argv = require('yargs').option('collection', {
      describe: 'collection to sync. if empty all collections are synced'
    }).option('resumable', {
      describe: 'should be resumable (state is stored in the .node-persist directory)',
      'default': true
    }).option('fresh', {
      describe: 'should be resumable (state is stored in the .node-persist directory)',
      'default': false
    }).option('threads', {
      describe: 'number of threads to use for syncing',
      'default': 1
    }).strict().argv;
    if (argv.fresh) {
      if (fs.existsSync('.node-persist')) {
        fs.removeSync('.node-persist');
      }
      if (fs.existsSync('listcollections')) {
        fs.unlinkSync('listcollections');
      }
    }
    if (argv.collection != null) {
      all_collections = [argv.collection];
    } else {
      if (!fs.existsSync('listcollections')) {
        all_collections = (await list_collections(db_src));
        fs.writeFileSync('listcollections', JSON.stringify(all_collections), 'utf-8');
      } else {
        all_collections = JSON.parse(fs.readFileSync('listcollections', 'utf-8'));
      }
    }
    dst_collections = (await list_collections(db_dst));
    dst_collections_set = new Set(dst_collections);
    num_to_sync = all_collections.length;
    num_threads = argv.threads;
    resumable = argv.resumable;
    if (resumable) {
      storage.initSync();
    }
    start_thread = async function(threadnum){
      var i$, ref$, len$, idx, x, is_incremental, results$ = [];
      for (i$ = 0, len$ = (ref$ = all_collections).length; i$ < len$; ++i$) {
        idx = i$;
        x = ref$[i$];
        if (idx % num_threads !== threadnum) {
          continue;
        }
        if (resumable && storage.getItemSync(x)) {
          console.log('' + idx + '/' + num_to_sync + ' thread ' + threadnum + ' already synced ' + x);
          continue;
        }
        console.log('' + idx + '/' + num_to_sync + ' thread ' + threadnum + ' syncing ' + x);
        is_incremental = dst_collections_set.has(x);
        if (is_incremental) {
          (await sync_all_in_collection(x, db_src, db_dst));
        } else {
          (await sync_all_in_collection_fresh(x, db_src, db_dst));
        }
        if (resumable) {
          results$.push(storage.setItemSync(x, true));
        }
      }
      return results$;
    };
    for (i$ = 0; i$ < num_threads; ++i$) {
      threadnum = i$;
      results$.push(start_thread(threadnum));
    }
    return results$;
  })();
}).call(this);
