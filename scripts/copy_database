#!/usr/bin/env node
// Generated by LiveScript 1.5.0
(function(){
  var mongodb, getsecret, n2p, process, fs, exec, storage, mongourl, mongourl2, memoizeSingleAsync, get_mongo_db, get_mongo_db2, sleep, keep_trying, sync_all_in_collection, sync_all_in_collection_fresh, list_collections, drop_db_by_url, set_mongourl_to_inactive, out$ = typeof exports != 'undefined' && exports || this;
  mongodb = require('mongodb');
  getsecret = require('getsecret');
  n2p = require('n2p');
  process = require('process');
  fs = require('fs-extra');
  exec = require('shelljs').exec;
  storage = require('node-persist');
  mongourl = getsecret('MONGODB_SRC');
  mongourl2 = getsecret('MONGODB_DST');
  memoizeSingleAsync = function(func){
    var cached_promise;
    cached_promise = null;
    return function(){
      var result;
      if (cached_promise != null) {
        return cached_promise;
      }
      result = func();
      cached_promise = result;
      return result;
    };
  };
  out$.get_mongo_db = get_mongo_db = memoizeSingleAsync(async function(){
    var err;
    try {
      return (await n2p(function(it){
        return mongodb.MongoClient.connect(mongourl, {
          readPreference: mongodb.ReadPreference.SECONDARY,
          readConcern: {
            level: 'available'
          },
          w: 0
        }, it);
      }));
    } catch (e$) {
      err = e$;
      console.error('error getting mongodb');
      console.error(err);
    }
  });
  out$.get_mongo_db2 = get_mongo_db2 = memoizeSingleAsync(async function(){
    var err;
    try {
      return (await n2p(function(it){
        return mongodb.MongoClient.connect(mongourl2, {
          readPreference: mongodb.ReadPreference.SECONDARY,
          readConcern: {
            level: 'available'
          },
          w: 0
        }, it);
      }));
    } catch (e$) {
      err = e$;
      console.error('error getting mongodb2');
      console.error(err);
    }
  });
  sleep = async function(time){
    return new Promise(function(it){
      return setTimeout(it, time);
    });
  };
  keep_trying = async function(fn){
    var succeeded, output, error;
    succeeded = false;
    while (!succeeded) {
      try {
        output = (await n2p(fn));
        succeeded = true;
      } catch (e$) {
        error = e$;
        console.log(error);
        (await sleep(12000));
      }
    }
    return output;
  };
  sync_all_in_collection = async function(collection_name, db_src, db_dst){
    var c_src, c_dst, all_ids_src, all_ids_dst, all_ids_dst_str, dst_id_set, all_ids_which_need_to_be_inserted, all_items_src, all_items_which_need_to_be_inserted, i$, len$, idx, idname, item_src, this$ = this;
    c_src = db_src.collection(collection_name);
    c_dst = db_dst.collection(collection_name);
    all_ids_src = (await keep_trying(function(it){
      return c_src.find({}, {
        _id: 1
      }).toArray(it);
    }));
    all_ids_src = all_ids_src.map(function(it){
      return it._id;
    });
    if (all_ids_src.length === 0) {
      return;
    }
    all_ids_dst = (await keep_trying(function(it){
      return c_dst.find({}, {
        _id: 1
      }).toArray(it);
    }));
    all_ids_dst = all_ids_dst.map(function(it){
      return it._id;
    });
    all_ids_dst_str = all_ids_dst.map(function(it){
      return it.toString();
    });
    dst_id_set = new Set(all_ids_dst_str);
    all_ids_which_need_to_be_inserted = all_ids_src.filter(function(x){
      return !dst_id_set.has(x.toString());
    });
    if (all_ids_which_need_to_be_inserted.length === 0) {
      return;
    }
    if (all_ids_which_need_to_be_inserted.length * 2 >= all_ids_src.length) {
      console.log('bulk incrementally inserting ' + all_ids_which_need_to_be_inserted.length + ' items');
      all_items_src = (await keep_trying(function(it){
        return c_src.find({}).toArray(it);
      }));
      if (all_items_src.length === 0) {
        return;
      }
      all_items_which_need_to_be_inserted = all_items_src.filter(function(x){
        return !dst_id_set.has(x._id.toString());
      });
      if (all_items_which_need_to_be_inserted.length === 0) {
        return;
      }
      (await keep_trying(function(it){
        return c_dst.insertMany(all_items_which_need_to_be_inserted, it);
      }));
    } else {
      console.log('individually incrementally inserting ' + all_ids_which_need_to_be_inserted.length + ' items');
      for (i$ = 0, len$ = all_ids_which_need_to_be_inserted.length; i$ < len$; ++i$) {
        idx = i$;
        idname = all_ids_which_need_to_be_inserted[i$];
        if (idx % 100 === 0) {
          console.log(idx + ' / ' + all_ids_which_need_to_be_inserted.length);
        }
        item_src = (await keep_trying(fn$));
        if (item_src == null) {
          console.log('could not find item with id ' + idname + ' in collection ' + collection_name);
          process.exit();
        }
        (await keep_trying(fn1$));
      }
    }
    function fn$(it){
      return c_src.find({
        _id: idname
      }).toArray(it);
    }
    function fn1$(it){
      return c_dst.insert(item_src, it);
    }
  };
  sync_all_in_collection_fresh = async function(collection_name, db_src, db_dst){
    var c_src, c_dst, all_items_src;
    c_src = db_src.collection(collection_name);
    c_dst = db_dst.collection(collection_name);
    all_items_src = (await keep_trying(function(it){
      return c_src.find({}).toArray(it);
    }));
    if (all_items_src.length === 0) {
      return;
    }
    console.log('freshly inserting ' + all_items_src.length + ' items');
    return (await keep_trying(function(it){
      return c_dst.insertMany(all_items_src, it);
    }));
  };
  list_collections = async function(db_src){
    var collections_src, all_items_src, output, this$ = this;
    collections_src = db_src.collection('collections');
    all_items_src = (await keep_trying(function(it){
      return collections_src.find({}, {
        _id: 1
      }).toArray(it);
    }));
    output = all_items_src.map(function(it){
      return it._id;
    });
    if (output.indexOf('collections') === -1) {
      output.push('collections');
    }
    return output;
  };
  drop_db_by_url = async function(url){
    var db;
    db = (await n2p(function(it){
      return mongodb.MongoClient.connect(url, {
        readPreference: mongodb.ReadPreference.SECONDARY,
        readConcern: {
          level: 'available'
        },
        w: 0
      }, it);
    }));
    (await n2p(function(it){
      return db.dropDatabase(it);
    }));
  };
  set_mongourl_to_inactive = function(){
    var mongodb_uri_heroku, mongodb_uri_server1_heroku, mongodb_uri_server2_heroku;
    mongodb_uri_heroku = exec('heroku config:get MONGODB_URI --app habitlab').stdout.trim();
    mongodb_uri_server1_heroku = exec('heroku config:get MONGODB_URI_SERVER1 --app habitlab').stdout.trim();
    mongodb_uri_server2_heroku = exec('heroku config:get MONGODB_URI_SERVER2 --app habitlab').stdout.trim();
    if (!mongodb_uri_heroku.startsWith('mongodb://') || !mongodb_uri_server1_heroku.startsWith('mongodb://') || !mongodb_uri_server2_heroku.startsWith('mongodb://')) {
      console.log('heroku config vars MONGODB_URI MONGODB_URI_SERVER1 MONGODB_URI_SERVER2 must all be set');
      process.exit();
    }
    if (mongodb_uri_heroku === mongodb_uri_server1_heroku && mongodb_uri_heroku !== mongodb_uri_server2_heroku) {
      mongourl = mongodb_uri_server2_heroku;
    } else if (mongodb_uri_heroku !== mongodb_uri_server1_heroku && mongodb_uri_heroku === mongodb_uri_server2_heroku) {
      mongourl = mongodb_uri_server1_heroku;
    } else {
      console.log('MONGODB_URI must equal one of either MONGODB_URI_SERVER1 or MONGODB_URI_SERVER2');
      process.exit();
    }
  };
  (async function(){
    var argv, db_src, db_dst, all_collections, dst_collections, dst_collections_set, num_to_sync, num_threads, resumable, thread_to_finished, res$, i$, ref$, len$, x, start_thread, threadnum, fn$ = async function(){
      var i$, to$, results$ = [];
      for (i$ = 0, to$ = num_threads; i$ < to$; ++i$) {
        results$.push(i$);
      }
      return results$;
    }, results$ = [];
    argv = require('yargs').option('collection', {
      describe: 'collection to sync. if empty all collections are synced'
    }).option('resumable', {
      describe: 'should be resumable (state is stored in the .node-persist directory)',
      'default': true
    }).option('fresh', {
      describe: 'should be resumable (state is stored in the .node-persist directory)',
      'default': false
    }).option('threads', {
      describe: 'number of threads to use for syncing',
      'default': 1
    }).option('printnonactive', {
      describe: 'print the mongourl of the non-active server',
      'default': false
    }).option('syncnonactive', {
      describe: 'use the non-active server as the source instead of MONGODB_SRC',
      'default': false
    }).option('dropnonactive', {
      describe: 'drop the non-active server database',
      'default': false
    }).option('switchactive', {
      describe: 'switch the currently active server',
      'default': false
    }).strict().argv;
    if (argv.printnonactive) {
      set_mongourl_to_inactive();
      console.log(mongourl);
      process.exit();
    }
    if (argv.syncnonactive) {
      set_mongourl_to_inactive();
    }
    if (argv.dropnonactive) {
      set_mongourl_to_inactive();
      console.log('droping database');
      console.log(mongourl);
      (await drop_db_by_url(mongourl));
      console.log('done');
      process.exit();
    }
    if (argv.switchactive) {
      set_mongourl_to_inactive();
      exec("heroku config:set MONGODB_URI='" + mongourl + "' --app habitlab");
      console.log('done setting mongourl to inactive');
      process.exit();
    }
    db_src = (await get_mongo_db());
    db_dst = (await get_mongo_db2());
    if (argv.fresh) {
      if (fs.existsSync('.node-persist')) {
        fs.removeSync('.node-persist');
      }
      if (fs.existsSync('listcollections')) {
        fs.unlinkSync('listcollections');
      }
    }
    if (argv.collection != null) {
      all_collections = [argv.collection];
    } else {
      if (!fs.existsSync('listcollections')) {
        all_collections = (await list_collections(db_src));
        fs.writeFileSync('listcollections', JSON.stringify(all_collections), 'utf-8');
      } else {
        all_collections = JSON.parse(fs.readFileSync('listcollections', 'utf-8'));
      }
    }
    dst_collections = (await list_collections(db_dst));
    dst_collections_set = new Set(dst_collections);
    num_to_sync = all_collections.length;
    num_threads = argv.threads;
    resumable = argv.resumable;
    if (resumable) {
      storage.initSync();
    }
    res$ = [];
    for (i$ = 0, len$ = (ref$ = (await (fn$()))).length; i$ < len$; ++i$) {
      x = ref$[i$];
      res$.push(false);
    }
    thread_to_finished = res$;
    start_thread = async function(threadnum){
      var i$, ref$, len$, idx, x, is_incremental;
      for (i$ = 0, len$ = (ref$ = all_collections).length; i$ < len$; ++i$) {
        idx = i$;
        x = ref$[i$];
        if (idx % num_threads !== threadnum) {
          continue;
        }
        if (resumable && storage.getItemSync(x)) {
          console.log('' + idx + '/' + num_to_sync + ' thread ' + threadnum + ' already synced ' + x);
          continue;
        }
        console.log('' + idx + '/' + num_to_sync + ' thread ' + threadnum + ' syncing ' + x);
        is_incremental = dst_collections_set.has(x);
        if (is_incremental) {
          (await sync_all_in_collection(x, db_src, db_dst));
        } else {
          (await sync_all_in_collection_fresh(x, db_src, db_dst));
        }
        if (resumable) {
          storage.setItemSync(x, true);
        }
      }
      return thread_to_finished[threadnum] = true;
    };
    for (i$ = 0; i$ < num_threads; ++i$) {
      threadnum = i$;
      start_thread(threadnum);
    }
    for (;;) {
      console.log(thread_to_finished);
      (await sleep(10000));
      if (thread_to_finished.indexOf(false) === -1) {
        console.log('all finished');
        results$.push(process.exit());
      }
    }
    return results$;
  })();
}).call(this);
